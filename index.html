<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Custom Teachable Machine</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
  font-family: Arial, sans-serif;
  background: #111;
  color: white;
  margin: 0;
  padding: 0;
}

/* DEVICE SELECTION */
#deviceSelectScreen {
  width: 100%;
  height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.deviceButton {
  padding: 20px;
  margin: 12px;
  font-size: 22px;
  width: 250px;
  background: #444;
  border: none;
  border-radius: 15px;
  color: white;
  cursor: pointer;
}

/* MAIN UI */
#mainUI {
  display: none;
  padding: 20px;
}

#deviceModeLabel {
  text-align: center;
  margin-bottom: 20px;
}

/* Webcam */
#webcamContainer {
  text-align: center;
}

#video {
  border-radius: 12px;
  width: 100%;
  max-width: 500px;
}

/* Class Sidebar */
#classSidebar {
  background: #222;
  padding: 15px;
  border-radius: 12px;
  margin-top: 18px;
}

.classItem {
  padding: 10px;
  margin: 8px 0;
  background: #333;
  border-radius: 8px;
}

.classControls button {
  margin-right: 6px;
}

/* Emoji Picker */
#emojiPicker {
  display: none;
  background: #333;
  padding: 10px;
  border-radius: 12px;
  margin-top: 12px;
}
.emojiOption {
  font-size: 26px;
  cursor: pointer;
  padding: 5px;
}
</style>
</head>

<body>

<!-- DEVICE SELECT -->
<div id="deviceSelectScreen">
  <h1>Select Device</h1>
  <button class="deviceButton" onclick="launchApp('phone')">üì± Phone</button>
  <button class="deviceButton" onclick="launchApp('computer')">üíª Computer</button>
</div>

<!-- MAIN UI -->
<div id="mainUI">

  <h2 id="deviceModeLabel"></h2>

  <div id="webcamContainer">
    <video id="video" autoplay playsinline></video><br>
    <button id="captureBtn">üì∏ Capture</button>
    <button onclick="startTesting()">‚ñ∂ Live Test</button>
    <button onclick="stopTesting()">‚èπ Stop</button>
  </div>

  <h3>Add Class</h3>
  <input id="classNameInput" placeholder="Class name"><br><br>
  <button onclick="openEmojiPicker()">Pick Emoji</button>
  <button onclick="addClass()">Create Class</button>
  <div id="selectedEmoji"></div>
  <div id="emojiPicker"></div>

  <h3>Classes</h3>
  <div id="classSidebar"></div>

  <br><br>

  <h3>Training</h3>
  <button onclick="trainModel()">‚ö° Train Model</button>
  <div id="trainingProgress"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>

<script>
let deviceMode = "";
let video = null;
let stream = null;
let classes = [];
let currentEmoji = "";
let currentClassIndex = -1;
let model = null;
let testing = false;
let liveInterval = null;
let captureInterval = null;

/* DEVICE LAUNCH */
async function launchApp(mode) {
  deviceMode = mode;
  document.getElementById("deviceModeLabel").innerText =
    "Device: " + (mode === "phone" ? "üì± Phone" : "üíª Computer");

  document.getElementById("deviceSelectScreen").style.display = "none";
  document.getElementById("mainUI").style.display = "block";

  await setupCamera(mode);
}

/* CAMERA SETUP */
async function setupCamera(mode) {
  video = document.getElementById("video");

  let constraints = { audio: false, video: {} };

  if (mode === "phone") constraints.video = { facingMode: "environment" };
  else constraints.video = { width: 1280, height: 720 };

  stream = await navigator.mediaDevices.getUserMedia(constraints);
  video.srcObject = stream;

  return new Promise(res => {
    video.onloadedmetadata = () => res();
  });
}

/* EMOJI PICKER */
function openEmojiPicker() {
  const picker = document.getElementById("emojiPicker");
  picker.style.display = "block";
  picker.innerHTML = "";
  const emojis = ["üòÄ","üòé","ü§ñ","üöó","üö¶","üèéÔ∏è","üö¥‚Äç‚ôÇÔ∏è","üê±","üê∂","üåü","üî•","üíß","üçé","‚ö°"];
  emojis.forEach(e => {
    const span = document.createElement("span");
    span.className = "emojiOption";
    span.innerText = e;
    span.onclick = () => {
      currentEmoji = e;
      document.getElementById("selectedEmoji").innerText = "Selected Emoji: " + e;
      picker.style.display = "none";
    };
    picker.appendChild(span);
  });
}

/* ADD CLASS */
function addClass() {
  const nameInput = document.getElementById("classNameInput");
  const name = nameInput.value.trim();
  if (!name) { alert("Enter a class name"); return; }
  classes.push({name: name, emoji: currentEmoji, images: []});
  currentEmoji = "";
  nameInput.value = "";
  document.getElementById("selectedEmoji").innerText = "";
  renderClasses();
}

/* RENDER CLASSES */
function renderClasses() {
  const container = document.getElementById("classSidebar");
  container.innerHTML = "";
  classes.forEach((cls, idx) => {
    const div = document.createElement("div");
    div.className = "classItem";
    div.innerHTML = `<strong>${cls.emoji || ""} ${cls.name}</strong> <br>
      Photos: ${cls.images.length} <br>
      <div class="classControls">
        <button onclick="deleteClass(${idx})">‚ùå Delete</button>
        <button onclick="clearClass(${idx})">üóë Clear Photos</button>
        <button onclick="selectClass(${idx})">üéØ Select</button>
      </div>`;
    container.appendChild(div);
  });
}

/* CLASS CONTROL */
function selectClass(idx) { currentClassIndex = idx; alert("Selected class: " + classes[idx].name); }
function deleteClass(idx) { classes.splice(idx,1); renderClasses(); }
function clearClass(idx) { classes[idx].images = []; renderClasses(); }

/* IMAGE CAPTURE */
function captureImage() {
  if (currentClassIndex < 0) { alert("Select a class first"); return; }
  const canvas = document.createElement("canvas");
  canvas.width = 224; canvas.height = 224;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(video,0,0,224,224);
  const dataUrl = canvas.toDataURL();
  classes[currentClassIndex].images.push(dataUrl);
  renderClasses();
}

/* FAST CAPTURE */
const captureBtn = document.getElementById("captureBtn");
captureBtn.addEventListener('mousedown', () => {
  if (currentClassIndex < 0) return;
  captureInterval = setInterval(captureImage, 200);
});
captureBtn.addEventListener('mouseup', () => { clearInterval(captureInterval); });
captureBtn.addEventListener('mouseleave', () => { clearInterval(captureInterval); });

/* TRAIN MODEL */
async function trainModel() {
  if (classes.length === 0) { alert("Add classes first"); return; }

  const xs = [];
  const ys = [];
  const labels = [];

  let totalImages = classes.reduce((a,b)=>a+b.images.length,0);
  if (totalImages===0){ alert("Capture some images first"); return; }

  classes.forEach((cls, idx) => {
    cls.images.forEach(imgData => {
      const img = new Image();
      img.src = imgData;
      img.onload = () => {
        const tensor = tf.browser.fromPixels(img).resizeNearestNeighbor([224,224]).toFloat().div(255);
        xs.push(tensor);
        ys.push(idx);
        labels[idx] = cls.name;
        if (xs.length === totalImages) startTraining(xs, ys, labels);
      };
    });
  });
}

async function startTraining(xsArray, ysArray, labels) {
  const xs = tf.stack(xsArray);
  const ys = tf.oneHot(tf.tensor1d(ysArray,'int32'), labels.length);

  model = tf.sequential();
  const mobilenet = await tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v3_small_100_224/model.json');
  mobilenet.trainable = false;
  model.add(tf.layers.inputLayer({inputShape:[224,224,3]}));
  model.add(mobilenet);
  model.add(tf.layers.flatten());
  model.add(tf.layers.dense({units: labels.length, activation:'softmax'}));

  model.compile({optimizer:'adam', loss:'categoricalCrossentropy', metrics:['accuracy']});

  const progressDiv = document.getElementById("trainingProgress");
  progressDiv.innerText = "Training started...";

  await model.fit(xs, ys, {
    epochs: 5,
    callbacks: {
      onEpochEnd: (epoch, logs) => {
        progressDiv.innerText = `Epoch ${epoch+1}/5 - Loss: ${logs.loss.toFixed(3)} - Accuracy: ${(logs.acc*100).toFixed(2)}%`;
      },
      onTrainEnd: () => {
        progressDiv.innerText = "Training complete!";
      }
    }
  });

  xs.dispose(); ys.dispose();
  alert("Model trained!");
}

/* LIVE TESTING */
function startTesting() {
  if (!model) { alert("Train a model first"); return; }
  testing = true;
  liveInterval = setInterval(async () => {
    const tensor = tf.browser.fromPixels(video).resizeNearestNeighbor([224,224]).toFloat().div(255).expandDims();
    const prediction = model.predict(tensor);
    const values = prediction.dataSync();
    const maxIndex = values.indexOf(Math.max(...values));
    const className = classes[maxIndex] ? classes[maxIndex].name : "Unknown";
    const emoji = classes[maxIndex] ? classes[maxIndex].emoji : "";
    document.getElementById("deviceModeLabel").innerText =
      `Prediction: ${emoji} ${className} (${(values[maxIndex]*100).toFixed(1)}%)`;
    tensor.dispose(); prediction.dispose();
  }, 500);
}

function stopTesting() {
  testing = false;
  clearInterval(liveInterval);
}
</script>
</body>
</html>
