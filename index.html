<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Dark Mode Teachable Machine Clone</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>
<style>
body {font-family: Arial; margin:0; padding:0; background:#111; color:white;}
#header {text-align:center;padding:15px;font-size:22px;}
#container {display:flex; flex-wrap:wrap;}
#webcamContainer {flex:1; text-align:center;}
#video {border-radius:12px; width:100%; max-width:500px;}
#captureBtn {margin:10px;padding:8px 16px;font-size:18px; cursor:pointer;}
#classSidebar {flex:1; max-width:300px; background:#222; padding:10px; border-radius:12px; margin-left:10px;}
.classItem {padding:10px; margin:6px 0; border-radius:8px; background:#333;}
.classControls button {margin:2px;}
.progressBarContainer {background:#333; height:20px; width:100%; border-radius:10px; margin-top:4px;}
.progressBar {height:100%; border-radius:10px; background:#4caf50; width:0%;}
#emojiPicker span{font-size:26px; padding:5px; cursor:pointer;}
button {background:#444; color:white; border:none; border-radius:6px;}
button:hover {background:#555;}
</style>
</head>
<body>

<div id="header">Custom Dark Mode Teachable Machine</div>
<div id="container">
<div id="webcamContainer">
<video id="video" autoplay playsinline></video><br>
<button id="captureBtn">üì∏ Capture Fast</button>
<button onclick="startTesting()">‚ñ∂ Live Test</button>
<button onclick="stopTesting()">‚èπ Stop</button><br>
<input type="file" id="uploadImages" accept="image/*" multiple>
<button onclick="addUploadedImages()">Add Uploaded Images to Selected Class</button>
<div id="predictions"></div>
<br>
<button onclick="saveModel()">üíæ Save Model</button>
<input type="file" id="loadModelFile" webkitdirectory directory multiple>
<button onclick="loadModel()">üìÇ Load Model</button>
</div>

<div id="classSidebar">
<h3>Add Class</h3>
<input id="classNameInput" placeholder="Class name"><br>
<button onclick="openEmojiPicker()">Pick Emoji</button>
<button onclick="addClass()">Create Class</button>
<div id="selectedEmoji"></div>
<div id="emojiPicker" style="display:none;"></div>

<h3>Classes</h3>
<div id="classesList"></div>
</div>
</div>

<div style="margin-top:20px;">
<h3>Train Model</h3>
<button onclick="trainModel()">‚ö° Train Model</button>
<div id="trainingProgress"></div>
</div>

<script>
let video,stream,classes=[],currentClassIndex=-1,currentEmoji="",model=null,testing=false,liveInterval=null,captureInterval=null;

/* CAMERA SETUP */
async function setupCamera(){
video=document.getElementById("video");
let constraints={audio:false, video:{facingMode:"environment"}};
stream=await navigator.mediaDevices.getUserMedia(constraints);
video.srcObject=stream;
return new Promise(res=>video.onloadedmetadata=()=>res());
}
setupCamera();

/* EMOJI PICKER */
function openEmojiPicker(){
const picker=document.getElementById("emojiPicker");
picker.style.display="block"; picker.innerHTML="";
const emojis=["üòÄ","üòé","ü§ñ","üöó","üö¶","üèéÔ∏è","üö¥‚Äç‚ôÇÔ∏è","üê±","üê∂","üåü","üî•","üíß","üçé","‚ö°"];
emojis.forEach(e=>{
const span=document.createElement("span"); span.innerText=e;
span.onclick=()=>{currentEmoji=e; document.getElementById("selectedEmoji").innerText="Selected Emoji: "+e; picker.style.display="none";};
picker.appendChild(span);
});
}

/* ADD CLASS */
function addClass(){
const name=document.getElementById("classNameInput").value.trim();
if(!name){alert("Enter a class name"); return;}
classes.push({name:name,emoji:currentEmoji,images:[],color:'#'+Math.floor(Math.random()*16777215).toString(16)});
currentEmoji=""; document.getElementById("classNameInput").value=""; document.getElementById("selectedEmoji").innerText="";
renderClasses();
}

/* RENDER CLASSES */
function renderClasses(){
const container=document.getElementById("classesList"); container.innerHTML="";
classes.forEach((cls,idx)=>{
const div=document.createElement("div"); div.className="classItem"; div.style.background=cls.color;
div.innerHTML=`<strong>${cls.emoji||""} ${cls.name}</strong> <br>Photos: ${cls.images.length} <br>
<div class="classControls">
<button onclick="deleteClass(${idx})">‚ùå Delete</button>
<button onclick="clearClass(${idx})">üóë Clear Photos</button>
<button onclick="selectClass(${idx})">üéØ Select</button>
</div>`;
container.appendChild(div);
});
}
function selectClass(idx){currentClassIndex=idx; alert("Selected class: "+classes[idx].name);}
function deleteClass(idx){classes.splice(idx,1); renderClasses();}
function clearClass(idx){classes[idx].images=[]; renderClasses();}

/* WEBCAM CAPTURE FAST */
const captureBtn=document.getElementById("captureBtn");
captureBtn.addEventListener('mousedown',()=>{if(currentClassIndex<0)return; captureInterval=setInterval(captureImage,200);});
captureBtn.addEventListener('mouseup',()=>{clearInterval(captureInterval);});
captureBtn.addEventListener('mouseleave',()=>{clearInterval(captureInterval);});
function captureImage(){
if(currentClassIndex<0){alert("Select a class"); return;}
const canvas=document.createElement("canvas"); canvas.width=224; canvas.height=224;
canvas.getContext("2d").drawImage(video,0,0,224,224);
classes[currentClassIndex].images.push(canvas.toDataURL());
renderClasses();
}

/* ADD UPLOADED IMAGES */
function addUploadedImages(){
if(currentClassIndex<0){alert("Select a class"); return;}
const files=document.getElementById("uploadImages").files;
for(let i=0;i<files.length;i++){
const reader=new FileReader();
reader.onload=(e)=>{classes[currentClassIndex].images.push(e.target.result); renderClasses();}
reader.readAsDataURL(files[i]);
}
}

/* TRAIN MODEL */
async function trainModel(){
if(classes.length===0){alert("Add classes first"); return;}
let totalImages=classes.reduce((a,b)=>a+b.images.length,0);
if(totalImages===0){alert("Add images first"); return;}
const xs=[],ys=[],labels=[];
classes.forEach((cls,idx)=>{cls.images.forEach(imgData=>{
const img=new Image(); img.src=imgData; img.onload=()=>{
const tensor=tf.browser.fromPixels(img).resizeNearestNeighbor([224,224]).toFloat().div(255);
xs.push(tensor); ys.push(idx); labels[idx]=cls.name;
if(xs.length===totalImages) startTraining(xs,ys,labels);
};
});});
}

async function startTraining(xsArray,ysArray,labels){
const xs=tf.stack(xsArray); const ys=tf.oneHot(tf.tensor1d(ysArray,'int32'),labels.length);
model=tf.sequential();
const mobilenet=await tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v3_small_100_224/model.json');
mobilenet.trainable=false;
model.add(tf.layers.inputLayer({inputShape:[224,224,3]}));
model.add(mobilenet);
model.add(tf.layers.flatten());
model.add(tf.layers.dense({units:labels.length,activation:'softmax'}));
model.compile({optimizer:'adam',loss:'categoricalCrossentropy',metrics:['accuracy']});
const progressDiv=document.getElementById("trainingProgress"); progressDiv.innerText="Training...";
await model.fit(xs,ys,{epochs:5,callbacks:{onEpochEnd:(epoch,logs)=>{progressDiv.innerText=`Epoch ${epoch+1}/5 - Loss:${logs.loss.toFixed(3)} - Acc:${(logs.acc*100).toFixed(2)}%`;},onTrainEnd:()=>{progressDiv.innerText="Training complete!";}}});
xs.dispose(); ys.dispose(); alert("Model trained!");
}

/* SAVE / LOAD MODEL */
async function saveModel(){if(!model){alert("Train first"); return;} await model.save('downloads://my_model'); alert("Model saved to your computer.");}
async function loadModel(){
const files=document.getElementById("loadModelFile").files; if(files.length===0){alert("Select model folder"); return;}
model=await tf.loadLayersModel(tf.io.browserFiles(Array.from(files))); alert("Model loaded!");
}

/* LIVE TESTING */
function startTesting(){
if(!model){alert("Train or load a model first"); return;}
testing=true; liveInterval=setInterval(async()=>{
const tensor=tf.browser.fromPixels(video).resizeNearestNeighbor([224,224]).toFloat().div(255).expandDims();
const prediction=model.predict(tensor); const values=prediction.dataSync();
showPredictions(values); tensor.dispose(); prediction.dispose();
},500);
}

function stopTesting(){testing=false; clearInterval(liveInterval);}

/* SHOW PREDICTIONS */
function showPredictions(values){
const container=document.getElementById("predictions"); container.innerHTML="";
values.forEach((v,i)=>{
const cls=classes[i]; if(!cls) return;
const bar=document.createElement("div"); bar.className="progressBarContainer";
const inner=document.createElement("div"); inner.className="progressBar"; inner.style.width=(v*100)+"%"; inner.style.background=cls.color;
bar.appendChild(inner);
const text=document.createElement("div"); text.innerText=`${cls.emoji||""} ${cls.name}: ${(v*100).toFixed(1)}%`;
container.appendChild(text); container.appendChild(bar);
});
}
</script>
</body>
</html>
