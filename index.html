<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Custom Teachable Machine</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
  font-family: Arial, sans-serif;
  background: #111;
  color: white;
  margin: 0;
  padding: 0;
}

/* Device selection screen */
#deviceSelectScreen {
  width: 100%;
  height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background: #000;
}

.deviceButton {
  padding: 20px;
  margin: 12px;
  font-size: 22px;
  width: 250px;
  background: #444;
  border: none;
  border-radius: 15px;
  color: white;
  cursor: pointer;
}

#mainUI {
  display: none;
  padding: 20px;
}

/* Webcam */
#webcamContainer {
  text-align: center;
}

#video {
  border-radius: 12px;
  width: 100%;
  max-width: 420px;
}

/* Class List Sidebar */
#classSidebar {
  background: #222;
  padding: 15px;
  border-radius: 12px;
  margin-top: 18px;
}

.classItem {
  padding: 10px;
  margin: 8px 0;
  background: #333;
  border-radius: 8px;
}

.classControls button {
  margin-right: 6px;
}

/* Emoji Picker */
#emojiPicker {
  display: none;
  background: #333;
  padding: 10px;
  border-radius: 12px;
  margin-top: 12px;
}
.emojiOption {
  font-size: 26px;
  cursor: pointer;
  padding: 5px;
}
</style>
</head>

<body>

<!-- DEVICE SELECT -->
<div id="deviceSelectScreen">
  <h1>Select Device</h1>
  <button class="deviceButton" onclick="launchApp('phone')">üì± Phone</button>
  <button class="deviceButton" onclick="launchApp('computer')">üíª Computer</button>
</div>

<!-- MAIN UI -->
<div id="mainUI">

  <h2 id="deviceModeLabel"></h2>

  <div id="webcamContainer">
    <video id="video" autoplay playsinline></video><br>
    <button onclick="captureImage()">üì∏ Capture</button>
    <button onclick="startTesting()">‚ñ∂ Live Test</button>
    <button onclick="stopTesting()">‚èπ Stop</button>
  </div>

  <h3>Add Class</h3>
  <input id="classNameInput" placeholder="Class name"><br><br>
  <button onclick="openEmojiPicker()">Pick Emoji</button>
  <button onclick="addClass()">Create Class</button>

  <div id="selectedEmoji"></div>
  <div id="emojiPicker"></div>

  <h3>Classes</h3>
  <div id="classSidebar"></div>

  <br><br>

  <h3>Training</h3>
  <button onclick="trainModel()">‚ö° Train Model</button>
  <div id="trainingProgress"></div>

  <br>

  <button onclick="exportModel()">üì§ Export Model</button>
  <br><br>
  <input type="file" id="tmZipInput" accept=".zip" onchange="loadTMZip(this.files)">
  <p>Upload Teachable Machine ZIP</p>

</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>

<!-- fflate embedded -->
<script src="https://cdn.jsdelivr.net/npm/fflate@0.8.0/umd/index.js"></script>

<script>
/* GLOBAL STATE */
let deviceMode = "";
let video = null;
let stream = null;
let classes = [];
let currentEmoji = "";
let model = null;
let testing = false;

/* DEVICE LAUNCH */
async function launchApp(mode) {
  deviceMode = mode;
  document.getElementById("deviceModeLabel").innerText =
    "Device: " + (mode === "phone" ? "üì± Phone" : "üíª Computer");

  document.getElementById("deviceSelectScreen").style.display = "none";
  document.getElementById("mainUI").style.display = "block";

  await setupCamera(mode);
}

/* CAMERA SETUP */
async function setupCamera(mode) {
  video = document.getElementById("video");

  let constraints = {
    audio: false,
    video: {}
  };

  if (mode === "phone") {
    constraints.video = { facingMode: "environment" };
  } else {
    constraints.video = { width: 1280, height: 720 };
  }

  stream = await navigator.mediaDevices.getUserMedia(constraints);
  video.srcObject = stream;

  return new Promise(res => {
    video.onloadedmetadata = () => res();
  });
}
/* ======================================================
   CLASSES & EMOJIS
======================================================*/
function openEmojiPicker() {
  const picker = document.getElementById("emojiPicker");
  picker.style.display = "block";
  picker.innerHTML = "";
  const emojis = ["üòÄ","üòé","ü§ñ","üöó","üö¶","üèéÔ∏è","üö¥‚Äç‚ôÇÔ∏è","üê±","üê∂","üåü","üî•","üíß","üçé","‚ö°"];
  emojis.forEach(e => {
    const span = document.createElement("span");
    span.className = "emojiOption";
    span.innerText = e;
    span.onclick = () => {
      currentEmoji = e;
      document.getElementById("selectedEmoji").innerText = "Selected Emoji: " + e;
      picker.style.display = "none";
    };
    picker.appendChild(span);
  });
}

function addClass() {
  const nameInput = document.getElementById("classNameInput");
  const name = nameInput.value.trim();
  if (!name) { alert("Enter a class name"); return; }
  classes.push({name: name, emoji: currentEmoji, images: []});
  currentEmoji = "";
  nameInput.value = "";
  document.getElementById("selectedEmoji").innerText = "";
  renderClasses();
}

function renderClasses() {
  const container = document.getElementById("classSidebar");
  container.innerHTML = "";
  classes.forEach((cls, idx) => {
    const div = document.createElement("div");
    div.className = "classItem";
    div.innerHTML = `<strong>${cls.emoji || ""} ${cls.name}</strong> <br>
      Photos: ${cls.images.length} <br>
      <div class="classControls">
        <button onclick="deleteClass(${idx})">‚ùå Delete</button>
        <button onclick="clearClass(${idx})">üóë Clear Photos</button>
        <button onclick="selectClass(${idx})">üéØ Select</button>
      </div>`;
    container.appendChild(div);
  });
}

let currentClassIndex = -1;

function selectClass(idx) {
  currentClassIndex = idx;
  alert("Selected class: " + classes[idx].name);
}

function deleteClass(idx) {
  classes.splice(idx,1);
  renderClasses();
}

function clearClass(idx) {
  classes[idx].images = [];
  renderClasses();
}

/* ======================================================
   IMAGE CAPTURE
======================================================*/
function captureImage() {
  if (currentClassIndex < 0) { alert("Select a class first"); return; }
  const canvas = document.createElement("canvas");
  canvas.width = 224;
  canvas.height = 224;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(video,0,0,224,224);
  const dataUrl = canvas.toDataURL();
  classes[currentClassIndex].images.push(dataUrl);
  renderClasses();
}
/* ======================================================
   TRAINING CUSTOM MODEL
======================================================*/
async function trainModel() {
  if (classes.length === 0) { alert("Add classes first"); return; }

  // Prepare datasets
  const xs = [];
  const ys = [];
  const labels = [];

  classes.forEach((cls, idx) => {
    cls.images.forEach(imgData => {
      const img = new Image();
      img.src = imgData;
      img.onload = () => {
        const tensor = tf.browser.fromPixels(img).resizeNearestNeighbor([224,224]).toFloat().div(255);
        xs.push(tensor);
        ys.push(idx);
        labels[idx] = cls.name;
        if (xs.length === classes.reduce((a,b)=>a+b.images.length,0)) {
          startTraining(xs, ys, labels);
        }
      };
    });
  });
}

async function startTraining(xsArray, ysArray, labels) {
  const xs = tf.stack(xsArray);
  const ys = tf.oneHot(tf.tensor1d(ysArray,'int32'), labels.length);

  model = tf.sequential();
  const mobilenet = await tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v3_small_100_224/model.json');
  mobilenet.trainable = false;
  model.add(tf.layers.inputLayer({inputShape:[224,224,3]}));
  model.add(mobilenet);
  model.add(tf.layers.flatten());
  model.add(tf.layers.dense({units: labels.length, activation:'softmax'}));

  model.compile({optimizer:'adam', loss:'categoricalCrossentropy', metrics:['accuracy']});

  const progressDiv = document.getElementById("trainingProgress");
  progressDiv.innerText = "Training started...";

  await model.fit(xs, ys, {
    epochs: 5,
    callbacks: {
      onEpochEnd: (epoch, logs) => {
        progressDiv.innerText = `Epoch ${epoch+1}/5 - Loss: ${logs.loss.toFixed(3)} - Accuracy: ${(logs.acc*100).toFixed(2)}%`;
      },
      onTrainEnd: () => {
        progressDiv.innerText = "Training complete!";
      }
    }
  });

  xs.dispose(); ys.dispose();
  alert("Model trained!");
}

/* ======================================================
   LIVE TESTING
======================================================*/
let liveInterval = null;

function startTesting() {
  if (!model) { alert("Train or load a model first"); return; }
  testing = true;
  liveInterval = setInterval(async () => {
    const tensor = tf.browser.fromPixels(video).resizeNearestNeighbor([224,224]).toFloat().div(255).expandDims();
    const prediction = model.predict(tensor);
    const values = prediction.dataSync();
    const maxIndex = values.indexOf(Math.max(...values));
    const className = classes[maxIndex] ? classes[maxIndex].name : "Unknown";
    const emoji = classes[maxIndex] ? classes[maxIndex].emoji : "";
    document.getElementById("deviceModeLabel").innerText =
      `Prediction: ${emoji} ${className} (${(values[maxIndex]*100).toFixed(1)}%)`;
    tensor.dispose(); prediction.dispose();
  }, 500);
}

function stopTesting() {
  testing = false;
  clearInterval(liveInterval);
}

/* ======================================================
   EXPORT / SAVE MODEL
======================================================*/
async function exportModel() {
  if (!model) { alert("Train or load a model first"); return; }
  await model.save('downloads://my-custom-model');
  alert("Model exported!");
}

/* ======================================================
   LOAD TEACHABLE MACHINE ZIP
======================================================*/
async function loadTMZip(files) {
  if (files.length === 0) return;
  const file = files[0];
  const buffer = await file.arrayBuffer();
  const unzip = fflate.unzipSync(new Uint8Array(buffer));
  let modelJsonStr = null, weightsBin = null, metadataStr = null;
  for (let key in unzip) {
    if (key.endsWith("model.json")) modelJsonStr = new TextDecoder().decode(unzip[key]);
    if (key.endsWith("weights.bin")) weightsBin = unzip[key];
    if (key.endsWith("metadata.json")) metadataStr = new TextDecoder().decode(unzip[key]);
  }
  if (!modelJsonStr || !weightsBin) { alert("Invalid ZIP"); return; }
  const modelBlob = new Blob([modelJsonStr], {type:'application/json'});
  const modelUrl = URL.createObjectURL(modelBlob);
  model = await tf.loadGraphModel(modelUrl);
  alert("Teachable Machine model loaded!");
}
/* ======================================================
   FAST CAPTURE MODE (HOLD BUTTON)
======================================================*/
let captureInterval = null;

document.querySelector('button[onclick="captureImage()"]').addEventListener('mousedown', () => {
  if (currentClassIndex < 0) return;
  captureInterval = setInterval(captureImage, 200);
});
document.querySelector('button[onclick="captureImage()"]').addEventListener('mouseup', () => {
  clearInterval(captureInterval);
});
document.querySelector('button[onclick="captureImage()"]').addEventListener('mouseleave', () => {
  clearInterval(captureInterval);
});

/* ======================================================
   MULTIPLE IMAGE UPLOAD PER CLASS
======================================================*/
function uploadImages(files) {
  if (currentClassIndex < 0) { alert("Select a class first"); return; }
  Array.from(files).forEach(file => {
    const reader = new FileReader();
    reader.onload = (e) => {
      classes[currentClassIndex].images.push(e.target.result);
      renderClasses();
    };
    reader.readAsDataURL(file);
  });
}

/* Add a hidden input for upload */
const uploadInput = document.createElement("input");
uploadInput.type = "file";
uploadInput.multiple = true;
uploadInput.accept = "image/*";
uploadInput.style.display = "none";
uploadInput.onchange = () => uploadImages(uploadInput.files);
document.body.appendChild(uploadInput);

/* Optional: attach a button to trigger upload */
const uploadBtn = document.createElement("button");
uploadBtn.innerText = "üì§ Upload Images";
uploadBtn.onclick = () => uploadInput.click();
document.getElementById("mainUI").appendChild(uploadBtn);

/* ======================================================
   EMOJI PICKER CUSTOMIZATION (Optional unlimited)
======================================================*/
function addCustomEmoji() {
  const emoji = prompt("Enter an emoji (or leave blank for none):");
  if (emoji) currentEmoji = emoji;
}

/* END OF FILE */
</script>
</body>
</html>
